#index:1,2
Nutz.Dao 实体注释(Entity Annotation)
	@Table
		类对象声明，表示一个 POJO 为一个Nutz.Dao可接受的对象，可以对应数据表或者视图 @Table("表或者视图名") 如果不声明值，
		那么 Nutz.Dao 将把该对象的 getClass().getSimpleName().toLowerCase() 作为数据表的名称
	
	@View
		声明一个实体的时候，有些时候你需要将它存在某一个Table中，但是你却希望从一个View中获取。这么做通常是希望View可以帮
		你做一些数据的统计方面的工作。
		
		Nutz.Dao 支持你为一个实体 声明一个 @Table 的同时也声明一个 @View，对于一个对象， Nutz.Dao的“增,删,改”操作
		将针对Table，而“查”操作将针对 View。 实际上，如果你没有声明 @View， 那么你声明的@Table 将作为@View 的默认设置。

	@Column 
		字段声明，表示当前字段可以被映射到数据库中， @Column("字段名") 可以指定到特定的数据库字段, 如果不指定，那么将采用
		field.getName()作为名字，大小写是否敏感将依各个不同的数据库来定。

	@Id
		字段声明，告诉 Nutz.Dao本字段将作为一个 ID来使用。默认的， Nutz.Dao将在每次向数据库中插入一个对象后，更新一下Id字段
		的值，因为它认为@Id 字段是默认自动增长的。
		
		如果想消除这个特性，由你自己来控制@Id字段的值，请这样 {#00A;*@Id(IdType.STATIC)} 来声明你的 ID 字段
	
	@Name
		字段声明，告诉Nutz.Dao 本字段将作为一个Name来使用。一个实体的@Name 一般在数据表中都会做了唯一性约束。 所以当你依靠
		@Name 来获取一个对象的时候，相当于Sql代码
		{{{<sql>
		SELECT * FROM table WHERE name='...';  
		}}}
	
	@NotNull
		字段声明, 如果你试图 Nutz.Dao 插入或者更新一个对象，给该字段赋null值将导致一个com.zzh.dao.FailToMakeSQLException
	
	@Default 
		字段声明，告诉 Nutz.Dao 本字段默认的值。 @Default("你的默认值") 这个默认值你可以写成动态的
		
		比如 @Default("${{name}}@abc.com") 当你插入的对象包括一个name 属性，这个属性值会替换 ${{name}}
		否则会用 ""(空串) 来替换 ${{name}}
	
	@Readonly
		声明成Readonly的字段在插入和更新时将被忽略
	
	@One
		在一个字段上声明一条一对一映射，这个声明需要你输入两个参数:

		target
			你的这个字段对应的实体类。通常，这个类得是你的字段的一个子类或者实现类。或者它能够顺利的通过 Nutz.castor 转换成
			你的字段。(在 Nutz.Lang Book 里，我们将详细讨论 Nutz 为你提供的这个崭新的转换框架。在 Nutz.Dao 中，这个框架几乎
			对你是透明的，只有极特殊的时候有可能你需要关心它)
		
		field
			参考字段名，这个字段为对应对象的 Java 字段名称。
		
	@Many
		声明一条多对多映射，这个声明需要你输入三个参数，其中一个是可选的:

		target
			对应的实体类名，意义和@One 一样
		field
			参考字段名，同 @One不同，这个参考字段是 target 类中的字段。
		key
			当你的字段类型是个Map 的时候，这个参数就有作用了。 因为 @Many 通常会被你加在一个数组字段，或者一个 Collection 
			字段上，当你打算将 @Many 加在一个 Map 字段上， Nutz.Dao 通过这个参数就可以知道，你的 Map 打算用目标对象的哪一个
			属性作为 key，从而正确为你的建立 Map。

		{#F00;*注意:} @Many 是一个略微让人疑惑的名称，你可能会想，你声明 @Many 的字段必须是一个容器或者数组，其实，它也可以
		是一个单个对象。对于 Nutz.Dao来说，@Many字段确切的意义是说：参考字段(@Many.field) 是存放在 target 对象里的，而 @One则
		表示参考字段是存放在当前对象的。 所以@Many 的确切意思是说“Can be Many”，
		因此你甚至可以这么写
		{{{<java>
		@Many(target=A.class,field="id") private A a;
		}}}
		那么你通过 dao.fetchMany() 将只返回一个结果。
	
	@ManyMany
		多对多的关联是数据库非常常见的一种设计，两个数据表通过第三张数据表进行关联，同@One 和 @Many 一样， Nutz.dao 提供了一个
		@ManyMany 的声明，需要你输入五个参数，其中一个也是可选的：

		target
			对应的实体类名，意义和@One 和 @Many 一样
		relation
			你中间的关联表的名称，这个关联表也可以动态的，详细请参看后面的动态表名这一节。
		from
			表示关联表中哪个字段代表主对象
		to
			表示关联表中哪个字段代表 target 对象
		key
			同 @Many 的参数意义一样。

		这里需要说明的是， 两个对象的关联是通过 Id 或者 Name 来关联的，关联的优先级为
		# @Id `<->` @Id
		# @Id `<->` @Name
		# @Name `<->` @Id
		# @Name `<->` @Name
		就是说，如果主对象有 @Id 优先通过 @Id 来代表主对象，那么关联表代表主对象的字段必须为整数。

	@Type
		虽然Nutz.Dao 通过 Java 的反射，在绝大多数情况下能知道怎么处理你的对象，但是对于某些类型，比如枚举类型，它就不知道怎么
		处理了，在数据库中到底保存成数字还是保存成字符串呢？ Nutz.Dao 在设计被要求自己不能通过访问数据表来获取如何操作数据库的
		知识，这个要求有助于将来进一步为其设计一些帮助工具，而且在绝大多数情况下，它也不需要去访问数据库。所以这里不得不增加一
		个新的声明，@Type 就是用来明确指定一个字段在数据库里需要保存成什么类型的。
		
		不过，在 Nutz.Dao 的第一版，@Type 只会对枚举类型发生作用，如果你不声明 @Type，那么你的枚举字段是按照字符的形式存放在数
		据库中的，但是你可以用 @Type(Types.INT) 来告诉 Nutz.Dao你要把这个枚举字段按照数字的方式存放在数据库中，值则是枚举值
		的 ordinal()


#summary 主模块-子模块-入口函数
=Top=
<p align="center"><font size=6>* 主模块-子模块-入口函数 *</font></p>
----
<p align="right"> <font color="#AAA" size="1"> * By * </font>    *zozoh* (<font color="#080"> zozohtnt@gmail.com </font>)</p>
<wiki:toc max_depth="2"/>
----

<p align="right">[#Top]</p>
=`主模块`=
任何一个类都可以作为主模块，只要你将其配置在 web.xml 中，这样的设计主要是为了方便一些非 JSP/Servlet 标注的 web 服务器整合 Nutz.mvc 框架。

在主模块中，你可以声明如下的注解：

      * [mvc @Modules - 声明应用的所有子模块 ]
      * [mvc @IocBy - 设置应用所采用的 Ioc 容器 ]
      * [mvc @SetupBy - 应用启动以及关闭时的额外处理 ]
      * [mvc @Views - 自定义的扩展视图 ]
      * [mvc @Localization - 应用的本地化字符串设定 ]
      * [mvc 所有入口函数上支持的注解 ]
          * 声明在主模块模块的注解，将作为所有[mvc 入口函数 ]的默认配置
          * 在[mvc 子模块 ]中的定义更为优先
----

<p align="right">[#Top]</p>
==`@Modules - 声明应用的所有子模块`==
指定子模块

{{{
@Modules({ UserModule.class, PetModule.class})
public class MainModule {
	...
}}}

自动搜索子模块

{{{
@Modules(scanPackage = true)
public class MainModule {
	...
}}}

将自动搜索主模块所在的包（包括子包）下所有的类，如果有类包括了一个以上的[mvc 入口函数 ]将被认为是模块类

半自动搜索子模块

{{{
@Modules(value={Abc.class, Xyz.class}, scanPackage = true)
public class MainModule {
	...
}}}

将自动搜索主模块类，Abc.class，Xyz.class 所在的包（包括子包）下所有的类，如果有类包括了一个以上的[mvc 入口函数 ]将被认为是模块类

----

<p align="right">[#Top]</p>
==`@IocBy - 设置应用所采用的 Ioc 容器`==
声明了 Ioc 容器的获取方式，详情请参看[mvc_with_ioc 同 Ioc 容器一起工作 ]一节

----

<p align="right">[#Top]</p>
==`@SetupBy - 应用启动以及关闭时的额外处理`==
在整个应用启动或者关闭时，你想做一些额外的处理工作，你可以实现一个org.nutz.mvc.Setup 接口，并将其配置在[mvc 主模块 ]上

{{{
@SetupBy(MyAppSetup.class)
public class MainModule {
	...
}}}



----

<p align="right">[#Top]</p>
==`@Views - 自定义的扩展视图`==
Nutz.Mvc 允许你定制自己的[mvc_view 视图 ]，如何使用这个注解，请参看[mvc_view `视图>定制自己的视图 `]一节

----

<p align="right">[#Top]</p>
==`@Localization - 应用的本地化字符串设定`==
Nutz.Mvc 允许你定制自己的本地化字符串存取方式，同时它也提供了默认的本地化字符串存取方式，请参看[mvc_localization 本地化字符串 ]一节

----

<p align="right">[#Top]</p>
=`子模块`=
任何类都可以作为子模块，只要通过[mvc @Modules 注解 ]声明到[mvc 主模块 ]上即可

在子模块，你可以声明

      * [mvc_with_ioc @InjectName 使用 Ioc 容器管理本模块 ]
      * [mvc 所有入口函数上支持的注解 ]
          * 声明在子模块的注解，将作为所有[mvc 入口函数 ]的默认配置
----

<p align="right">[#Top]</p>
=`入口函数`=
子模块中任何函数，只要是 public 的，且不是 static 的，都可以作为入口函数标记入口函数的方法是在其上标注注解[mvc @At ]

在入口函数上，你可以声明如下注解：

      * [mvc @At - 入口函数对应的 URL ]
      * [mvc @Ok - 成功视图 ]
      * [mvc @Fail - 失败视图 ]
      * [mvc @AdaptBy - HTTP 参数适配方式 ]
      * [mvc @Filter - 过滤器 ]
      * [mvc @Encoding - 输入输出编码 ]

<p align="right">[#Top]</p>
==`@At - 入口函数对应的 URL`==
只有标记了这个注解的函数才被认为是[mvc 入口函数 ]，例如

{{{
@At("/my/abc")
public void someFunc(){
	...
}}}

你也可以为该函数声明多个 URL

{{{
@At({"/my/abc", "/my/xyz"})
public void someFunc(){
	...
}}}



        * 你也可以为其声明路径参数，详细情况请参看[mvc_http_adaptor `适配器>路径参数 `]一节
        * 如果，你想详细了解 URL 映射的细节，请参看[mvc_url_mapping URL 映射 ]一节。

<p align="right">[#Top]</p>
==`@Ok - 成功视图`==
声明了入口函数的成功视图，即如果入口函数正常执行，将会通过这个视图将函数返回值渲染到 HTTP 响应中。当然，如果你的函数直接返回的就是一个视图对象，那么就不会使用成功视图（而是你返回的视图对象）来渲染HTTP 响应详细的介绍，请参看[mvc_view 视图 ]一节


<p align="right">[#Top]</p>
==`@Fail - 失败视图`==
声明了入口函数的失败视图，即如果入口函数抛出异常，将会通过这个视图将异常渲染到 HTTP 响应中详细的介绍，请参看[mvc_view 视图 ]一节


<p align="right">[#Top]</p>
==`@AdaptBy - HTTP 参数适配方式`==
将 HTTP 请求参数转变成你当前入口函数的参数的过程叫做<b>适配 </b>，这个注解就是声明这个适配器。如果你没有声明这个注解，默认的会采用 PairAdaptor 来适配 HTTP 请求参数。详细的介绍，请参看[mvc_http_adaptor 适配器 ]一节


<p align="right">[#Top]</p>
==`@Filter - 过滤器`==
详细介绍请参看[mvc_action_filter 过滤器 ]一节


<p align="right">[#Top]</p>
==`@Encoding - 输入输出编码`==
定义 HTTP 请求的输入输出编码，这个注解通常是会定义在[mvc 主模块 ]上面，从而保证整个应用有统一的输入输出设定

如果你不定义，默认的，Nutz.Mvc 会采用<b>UTF-8 </b>作为输入输出的编码

{{{
@Encoding(input="UTF-8",output="UTF-8")
}}}




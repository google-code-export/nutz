#summary Nutz.Mvc 概述
<p align="center"><font size=6>* Nutz.Mvc 概述 *</font></p>
----
<p align="right"> <font color="#AAA" size="1"> * By * </font>    *zozoh* (<font color="#080"> zozohtnt@gmail.com </font>)</p>
<wiki:toc max_depth="2"/>
----
=`几句话的介绍`=
Nutz.Mvc 是要和一个 Web 服务器 （比如 Tomcat）一起工作的，它存在的意义 *就是要把一个标准的 HTTP 请求，转发到某一个 Java 函数中 *。  

它的特点是：  

      * 帮你做参数的解析 （ _当然你自己可以随意扩展 _） 
      * 如果你愿意，你可以不用 View 来渲染 HTTP 输出流 
      * 提供几个基本的渲染方式 （比如 JSP, JSON） 
      * 除此以外，不内置更多的功能 
每一种 HTTP 请求，标识就是一个 URL，而每一个 Java 函数怎样和一个 URL 关联呢？ 最直接的办法就是在函数上声明一个 注解，这个注解，在 Nutz.Mvc 中，叫 @At  

你如果想快速开始，来一个 Hellow World， 那么请访问  [http://nutzdemo.googlecode.com nutzdemo.googlecode.com ]，上面的 Hello Mvc 是完全可以运行的  

----
=`图解 Nutz.Mvc`=
为了能让你更快速直观的了解 Nutz.Mvc 的工作方式，我提供下面两张图：  

==`每一次请求，都经过如下流程`==
http://www.dtresearch.cn/web/_temp/1026/wiki_imgs/nutz_mvc_workflow_overview.png  

Nutz.Mvc 根据 @At 注解，将一个 HTTP 请求映射到了一个函数，函数只有一个参数，会被路径参数 （1045） 填充。  

        * Nutz.Mvc 最基本的想法，就是通过注解 @At 将一个HTTP请求路径同一个 Java 函数关联起来。 
        * 并且，@At 支持你写多个路径 
==`更详细的流程`==
http://www.dtresearch.cn/web/_temp/1026/wiki_imgs/nutz_mvc_workflow_detail.png  

        * 声明了 @At 的函数被称为  *入口函数 *
        * 任何一个请求，都会经过四道工序 
            # *A * -  *过滤 *: 你通过 @Filters 注解可以为你的 *入口函数 *定义任意多的过滤器 
            # *B * -  *适配 *: 这个过程将 HTTP 输入流转换成 *入口函数 *的参数数组 
                * 默认的，它认为输入流是传统的名值对方式 
                * 更多的适配方式请参看  [mvc_http_adaptor.man 关于适配器 ]
                * 文件上传也是一种适配方式，请参看 UploadAdptor 
            # *C * -  *调用 *: 调用 *入口函数 *，你在里面需要调用相关的业务层代码。 
                * 如果你的业务比较复杂，为了解耦合，你可能需要 Ioc 容器的帮助，请参看  [mvc_ioc.man 同 Ioc 容器一起工作 ] 一节 
            # *D * -  *渲染 *: 根据 *入口函数 *的返回，渲染 HTTP Response。 
                * 如果返回是个 View，则用这个 View 来渲染 null （null? 是的，你没看错，这种情况 View 接口第三个参数会是 null） 
                    * 你可以用 org.nutz.mvc.view.ViewWrapper 将你的返回对象以及要返回的视图组合在一起返回，ViewWrapper 也是一个 View 
                * 否则用函数的 @Ok 注解声明的 View 来渲染 *入口函数 *的返回对象 
                * 如果你的函数处理过程中抛出了异常，用 @Error 注解声明的 View 来渲染异常对象 
----
=`你还需要知道`=
==`关于 @At`==
        * 声明了这个注解的函数就是 *入口函数 *
        * 可以一次声明多个 URL，比如： 
{{{
@At({"/fetch","/get"})
public Pet fetch(int petId){
	...
}}}

        * 它不仅可以声明在函数上，它也可以声明在模块类上 
            * 如果声明在模块上，模块上所有的 *入口函数 *的 URL 实际上都会被加上一个前缀 
            * 如果不声明值，默认值为模块类名的小写形式 
        * 一个入口函数真正映射的地址是:   *模块的@At + 自己的@At *
            * 如果在模块上声明 @At，如果不写值，那么值是模块的类名的小写形式 
            * 如果在入口函数上声明@At，如果不写值，那么值是函数名的小写形式 
----
==`通过 web.xml 挂接在 Jsp/Servlet 容器中`==
同大多数单纯的 Mvc 框架一样， Nutz.Mvc 也提供了一个 Servlet 作为同 JSP/Servlet 容器的挂载点。  

{{{
<web-app>
	<servlet>
		<servlet-name>nutz</servlet-name>
		<servlet-class>org.nutz.mvc.NutServlet</servlet-class>
		<init-param>
			<param-name>modules</param-name>
			<param-value>nutz.demo.mvc.MainModule</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	
	<servlet-mapping>
		<servlet-name>nutz</servlet-name>
		<url-pattern>*.nut</url-pattern>
	</servlet-mapping>
</web-app>
}}}

NutServlet 只需要一个参数 --  _一个类的全名 _。这个类被认为是 *主模块 *，整个应用的配置 信息将通过如下的注解声明在这个类上。  

||  <font color="#008800">@Modules </font>		 || 整个应用有哪些 *子模块 *， <font color="#FF0000">_子模块不能再嵌套子模块 _</font>  ||
||  <font color="#008800">@IocBy </font>		 || 整个应用，应采用何种方式进行反转注入。如果没有声明，整个应用将不支持 Ioc   ||
||  <font color="#008800">@Localization </font>	 || 整个应用的本地地化字符串的目录  ||
||  <font color="#008800">@SetupBy </font>		 || 应用启动的关闭时，应该进行的处理。  ||
||  <font color="#008800">@Views </font>		 || 扩展整个应用支持的视图模板类型  ||
||  <font color="#888888">@Ok </font>			 || 整个应用默认的成功视图  ||
||  <font color="#888888">@Fail </font>			 || 整个应用默认的失败视图  ||
||  <font color="#888888">@AdaptBy </font>		 || 整个应用默认的 HTTP 参数适配方式  ||
||  <font color="#888888">@Filters </font>		 || 整个应用默认的过滤器数组  ||
||  <font color="#888888">@Encoding </font>		 || 整个应用默认的输入输出字符编码  ||

        * 绿色的注解表示只能应用在主模块上 
        * 灰色的注解表示还可以应用在 *子模块 *以及 *入口函数 *上 
----
==`如何将函数参数和 HTTP 参数对应起来？`==
        * 这个过程被称为适配，执行这个过程的类需要实现 org.nutz.mvc.HttpAdaptor 接口 
        * 通过 @AdaptBy 注解，可以为每个 *子模块 *声明默认的适配方式 
            * 这个注解也可是直接声明在 *入口函数 *上 
        * [mvc_http_adaptor.man 关于适配器 ] 一节有更多的描述 
        * 默认的，Nutz.Mvc 将为你的 *入口函数 *应用 org.nutz.mvc.adaptor.PairAdaptor 
----
==`在入口函数上可以声明什么注解？`==
||  <font color="#888888">@At </font>			 || 函数对应的 URL  ||
||  <font color="#888888">@Ok </font>			 || 成功视图  ||
||  <font color="#888888">@Fail </font>			 || 失败视图  ||
||  <font color="#888888">@AdaptBy </font>		 || HTTP 参数适配方式  ||
||  <font color="#888888">@Filters </font>		 || 函数的过滤器数组  ||
||  <font color="#888888">@Encoding </font>		 || HTTP 请求的输入输出字符编码  ||

----
==`在子模块可以声明什么注解？`==
||  <font color="#008800">@InjectName </font>	 || Ioc 容器中，本模块对应的名称，如果不指明，表示这个模块是通过默认构造函数创建的  ||
||  <font color="#888888">@At </font>			 || 模块所有 *入口函数 *的 URL 前缀  ||
||  <font color="#888888">@Ok </font>			 || 模块默认成功视图  ||
||  <font color="#888888">@Fail </font>			 || 模块默认失败视图  ||
||  <font color="#888888">@AdaptBy </font>		 || 模块默认 HTTP 参数适配方式  ||
||  <font color="#888888">@Filters </font>		 || 模块默认的过滤器数组  ||
||  <font color="#888888">@Encoding </font>		 || 模块默认 HTTP 请求的输入输出字符编码  ||

        * 绿色的注解表示只能应用在子模块上 
        * 灰色的注解表示还可以应用在 *子模块 *以及 *入口函数 *上 
